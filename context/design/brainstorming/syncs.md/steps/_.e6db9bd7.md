---
timestamp: 'Thu Nov 06 2025 21:53:19 GMT-0500 (Eastern Standard Time)'
parent: '[[../20251106_215319.fa42d0c4.md]]'
content_id: e6db9bd7a50322c5b3615e1e65397cd140cdfb7966d81774b781fbd6fa6d9df4
---

# Architecture Overview

The concept design approach structures its architecture entirely around two fundamental building blocks:

1. **Concepts**: Self-contained, modular increments of functionality (e.g., `Sessioning`, `Posting`, `Commenting`).
2. **Synchronizations**: The rules that orchestrate interactions *between* concepts (e.g., "when a post is deleted, delete all its comments").

## Directory Structure

> **Important:** You should only need to add code within the `src/concepts` and `src/syncs` directories.

```
context/
design/
src/
├── concepts/       <-- YOUR CONCEPTS HERE
│   ├── Sessioning/
│   │   └── SessioningConcept.ts
│   ├── Posting/
│   │   └── PostingConcept.ts
│   └── ...
├── syncs/          <-- YOUR SYNCHRONIZATIONS HERE
│   ├── auth.sync.ts
│   └── posts.sync.ts
│
├── engine/         <-- Framework-provided (ignore)
├── utils/          <-- Framework-provided (ignore)
└── main.ts         <-- Entry-point (can configure logging)
```

## The `Requesting` Concept: Application Entry-point

The architecture will automatically spin up an HTTP server for your application. However, you might wonder how exactly an external HTTP request triggers your logic. This is handled by the provided concept called `Requesting`.

When an HTTP request hits the server, the Concept Engine automatically translates it into a `Requesting.request` action. You don't implement this concept; you just use its actions as triggers in your synchronizations.

> **Important:** by default, `Requesting` also includes *passthrough routes* that automatically generate routes for direct access to concept actions and queries. Please read the [Requesting README](../../src/concepts/Requesting/README.md) for more details.

For example, an incoming request like `POST /api/posts/create` with a JSON body `{ "title": "My First Post", "content": "Hello world!", "session": "s123" }` is automatically converted into an action that looks like this:

`Requesting.request({ path: "/posts/create", title: "My First Post", content: "Hello world!", session: "s123" })`

You can then write a [synchronization](implementing-synchronizations.md) to "catch" this action and do something useful with it:

```typescript
// in src/syncs/posts.sync.ts
const CreatePostOnRequest: Sync = ({ title, content, session, user }) => ({
    when: actions(
        // Catches the request from the engine
        [Requesting.request, { path: "/posts/create", title, content, session }, {}],
    ),
    where: (frames) => {
        // Authorizes the request by checking the session
        return frames
            .query(Sessioning.getUser, { session }, { user });
    },
    then: actions(
        // If we got here, we found a logged in user
        [Posting.create, { title, content, author: user }],
    ),
});
```

By creating the `Sessioning` and `Posting` concepts and including this synchronization, you created an operational and authenticated API endpoint for creating posts. The `Requesting` concept encapsulates the concerns surrounding HTTP requests, and therefore abstracted away the need for specifying a HTTP server, controllers, middleware, etc.

## Initialization

1. Configure any environment variables you need in `.env`
2. Build command: `deno run build` to scan and automatically generate imports for concepts/syncs.
3. Start command: `deno run start` to begin your server.

/\*\*
concept Feedback \[User, Item]
purpose provide quantitative (0-5) feedback about a specific item
principle after a user submits feedback about an item, they can later update, delete, or view the feedback to analyze their opinions

state
A set of Feedbacks with
an author User
a target Item
a rating Number

actions
submitFeedback (author: User, item: Item, rating: Number): (feedback: Feedback)
requires: rating is between 0-5
effects: creates a new Feedback, associating the author, target, and rating

updateFeedback (author: User, item: Item, newRating: Number): (feedback: Feedback)
requires: feedback for this item from this user exists, newRating is between 0-5
effects: updates the rating of the specified item to newRating

deleteFeedback (author: User, item: Item): (successful: Boolean)
requires: feedback for this item from this user exists
effects: returns True if the feedback from this user for this item is removed

/\_getFeedback (author: User, item: Item): (feedback: Feedback)
requires:
effects: returns the feedback from this user for this item

/\_getAllUserRatings (author: User): (feedbacks: set(Feedback))
requires:
effects: returns all feedback documents from this user
\*/

/\*\*
concept RestaurantMenu \[Restaurant, User]

purpose allow users to reliably view an up-to-date and comprehensive list of a restaurant's dishes to inform their choices and receive personalized recommendations

principle when a restaurant owner adds new dishes or removes unavailable ones, customers can always view an up-to-date menu to get a dish recommendation tailored to their preferences.

state
a set of MenuItems with
a restaurant Restaurant
a name String
a description String
a price Number

actions
addMenuItem (restaurant: Restaurant, name: String, description: String, price: Number): (menuItem: MenuItem)
requires: menu item with the given name does not already exist for this restaurant
effects: returns a newly created menu item with this restaurant, name, description, and price

```
updateMenuItem (menuItem: MenuItem, newDescription: String, newPrice: Number): (menuItem: MenuItem)
  requires: a menu item with the given ID exists
  effects: updates the description and/or price of the existing menu item and returns the updated menu item

removeMenuItem (menuItem: MenuItem): (success: Boolean)
  requires: menu item with the given ID exists
  effects: returns true and deletes the menu item

/_getMenuItems (restaurant: Restaurant): (menuItem: MenuItem)
  requires: true
  effects: returns a set of all menu items associated with the given restaurant, including their name, description, and price

/_getMenuItemDetails (menuItem: MenuItem): (name: String, description: String, price: Number)
  requires: menuItem with the given ID exists
  effects: returns the name, description, and price of the specified menu item

/_getRecommendation (restaurant: Restaurant, user: User): (recommendation: String)
  requires: a restaurant with the given ID exists and has at least one menu item; a user with the given ID exists
  effects: returns the name of a menu item from the specified restaurant that is recommended for the user via an LLM, based on their taste preferences and the current menu items. If no specific preferences are found, a generic recommendation may be provided.
```

\*/

/\*\*

concept UserAuthentication \[User]
purpose limit access to known users
principle if a user registers with a unique username and password, they can later log in using those
same credentials to prove their identity and gain access.

state
a set of Credentials with
a username String
a password String

actions
register (username: String, password: String): (user: User)
requires: no User exists with the given username
effects: creates and returns a new User and associates it with the provided username and password

```
  authenticate (username: String, password: String): (user: User)
      requires: a User exists with the given username, and the password matches the stored password for that User
      effects: returns the User associated with the credentials

  _getUsername (user: User) : (username: String)
      requires: user exists
      effects: returns username of user
```

\*/

/\*\*

* concept UserTastePreferences \[User, Dish]

purpose enable users to mark dishes as liked or disliked to build a profile of their taste preferences

principle when a user adds a dish to their liked list, that preference is recorded, influencing future recommendations

state
a set of Users with
a set of likedDishes Dish
a set of dislikedDishes Dish

actions
addLikedDish (user: User, dish: Dish)
requires:
effects: add dish to likedDishes for user. If user record does not exist, create it first with empty lists. If dish was previously in dislikedDishes, it is removed from there.

```
removeLikedDish (user: User, dish: Dish)
  requires: user exists, dish is in likedDishes for user
  effects: remove dish from likedDishes for user

addDislikedDish (user: User, dish: Dish)
  requires:
  effects: add dish to dislikedDishes for user. If user record does not exist, create it first with empty lists. If dish was previously in likedDishes, it is removed from there.

removeDislikedDish (user: User, dish: Dish)
  requires: user exists, dish exists, dish is in dislikedDishes for user
  effects: remove dish from dislikedDishes for user

_getLikedDishes (user: User): (dishes: set(Dish))
  requires: user exists
  effects: returns all dishes liked by the specified user

_getDislikedDishes (user: User): (dishes: set(Dish))
  requires: user exists
  effects: returns all dishes disliked by the specified user
```

\*/
